{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nconst _excluded = [\"groupId\", \"children\"];\nimport { isLeaf } from \"../../../models/gridColumnGrouping.js\";\nexport const createGroupLookup = columnGroupingModel => {\n  const groupLookup = {};\n  for (let i = 0; i < columnGroupingModel.length; i += 1) {\n    const node = columnGroupingModel[i];\n    if (isLeaf(node)) {\n      continue;\n    }\n    const {\n        groupId,\n        children\n      } = node,\n      other = _objectWithoutPropertiesLoose(node, _excluded);\n    if (!groupId) {\n      throw new Error('MUI X: An element of the columnGroupingModel does not have either `field` or `groupId`.');\n    }\n    if (process.env.NODE_ENV !== 'production' && !children) {\n      console.warn(`MUI X: group groupId=${groupId} has no children.`);\n    }\n    const groupParam = _extends({}, other, {\n      groupId\n    });\n    const subTreeLookup = createGroupLookup(children);\n    if (subTreeLookup[groupId] !== undefined || groupLookup[groupId] !== undefined) {\n      throw new Error(`MUI X: The groupId ${groupId} is used multiple times in the columnGroupingModel.`);\n    }\n    Object.assign(groupLookup, subTreeLookup);\n    groupLookup[groupId] = groupParam;\n  }\n  return groupLookup;\n};\n\n// This is the recurrence function that help writing `unwrapGroupingColumnModel()`\nconst recurrentUnwrapGroupingColumnModel = (columnGroupNode, parents, unwrappedGroupingModelToComplete) => {\n  if (isLeaf(columnGroupNode)) {\n    if (unwrappedGroupingModelToComplete[columnGroupNode.field] !== undefined) {\n      throw new Error([`MUI X: columnGroupingModel contains duplicated field`, `column field ${columnGroupNode.field} occurs two times in the grouping model:`, `- ${unwrappedGroupingModelToComplete[columnGroupNode.field].join(' > ')}`, `- ${parents.join(' > ')}`].join('\\n'));\n    }\n    unwrappedGroupingModelToComplete[columnGroupNode.field] = parents;\n    return;\n  }\n  const {\n    groupId,\n    children\n  } = columnGroupNode;\n  children.forEach(child => {\n    recurrentUnwrapGroupingColumnModel(child, [...parents, groupId], unwrappedGroupingModelToComplete);\n  });\n};\n\n/**\n * This is a function that provide for each column the array of its parents.\n * Parents are ordered from the root to the leaf.\n * @param columnGroupingModel The model such as provided in DataGrid props\n * @returns An object `{[field]: groupIds}` where `groupIds` is the parents of the column `field`\n */\nexport const unwrapGroupingColumnModel = columnGroupingModel => {\n  if (!columnGroupingModel) {\n    return {};\n  }\n  const unwrappedSubTree = {};\n  columnGroupingModel.forEach(columnGroupNode => {\n    recurrentUnwrapGroupingColumnModel(columnGroupNode, [], unwrappedSubTree);\n  });\n  return unwrappedSubTree;\n};\nexport const getColumnGroupsHeaderStructure = (orderedColumns, unwrappedGroupingModel, pinnedFields) => {\n  const getParents = field => unwrappedGroupingModel[field] ?? [];\n  const groupingHeaderStructure = [];\n  const maxDepth = Math.max(0, ...orderedColumns.map(field => getParents(field).length));\n  const haveSameParents = (field1, field2, depth) => {\n    const a = getParents(field1);\n    const b = getParents(field2);\n    for (let i = 0; i <= depth; i += 1) {\n      if (a[i] !== b[i]) {\n        return false;\n      }\n    }\n    return true;\n  };\n  const haveDifferentContainers = (field1, field2) => {\n    const left = pinnedFields?.left;\n    const right = pinnedFields?.right;\n    const inLeft1 = !!left?.includes(field1);\n    const inLeft2 = !!left?.includes(field2);\n    const inRight1 = !!right?.includes(field1);\n    const inRight2 = !!right?.includes(field2);\n    return inLeft1 !== inLeft2 || inRight1 !== inRight2;\n  };\n  for (let depth = 0; depth < maxDepth; depth += 1) {\n    const depthStructure = [];\n    for (let i = 0; i < orderedColumns.length; i += 1) {\n      const field = orderedColumns[i];\n      const groupId = getParents(field)[depth] ?? null;\n      if (depthStructure.length === 0) {\n        depthStructure.push({\n          columnFields: [field],\n          groupId\n        });\n        continue;\n      }\n      const lastGroup = depthStructure[depthStructure.length - 1];\n      const prevField = lastGroup.columnFields[lastGroup.columnFields.length - 1];\n      if (lastGroup.groupId !== groupId || !haveSameParents(prevField, field, depth) || haveDifferentContainers(prevField, field)) {\n        depthStructure.push({\n          columnFields: [field],\n          groupId\n        });\n      } else {\n        lastGroup.columnFields.push(field);\n      }\n    }\n    groupingHeaderStructure.push(depthStructure);\n  }\n  return groupingHeaderStructure;\n};","map":{"version":3,"names":["_extends","_objectWithoutPropertiesLoose","_excluded","isLeaf","createGroupLookup","columnGroupingModel","groupLookup","i","length","node","groupId","children","other","Error","process","env","NODE_ENV","console","warn","groupParam","subTreeLookup","undefined","Object","assign","recurrentUnwrapGroupingColumnModel","columnGroupNode","parents","unwrappedGroupingModelToComplete","field","join","forEach","child","unwrapGroupingColumnModel","unwrappedSubTree","getColumnGroupsHeaderStructure","orderedColumns","unwrappedGroupingModel","pinnedFields","getParents","groupingHeaderStructure","maxDepth","Math","max","map","haveSameParents","field1","field2","depth","a","b","haveDifferentContainers","left","right","inLeft1","includes","inLeft2","inRight1","inRight2","depthStructure","push","columnFields","lastGroup","prevField"],"sources":["C:/Users/ammar/Documents/GitHub/AD-XPDC/SRC/node_modules/@mui/x-data-grid/esm/hooks/features/columnGrouping/gridColumnGroupsUtils.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nconst _excluded = [\"groupId\", \"children\"];\nimport { isLeaf } from \"../../../models/gridColumnGrouping.js\";\nexport const createGroupLookup = columnGroupingModel => {\n  const groupLookup = {};\n  for (let i = 0; i < columnGroupingModel.length; i += 1) {\n    const node = columnGroupingModel[i];\n    if (isLeaf(node)) {\n      continue;\n    }\n    const {\n        groupId,\n        children\n      } = node,\n      other = _objectWithoutPropertiesLoose(node, _excluded);\n    if (!groupId) {\n      throw new Error('MUI X: An element of the columnGroupingModel does not have either `field` or `groupId`.');\n    }\n    if (process.env.NODE_ENV !== 'production' && !children) {\n      console.warn(`MUI X: group groupId=${groupId} has no children.`);\n    }\n    const groupParam = _extends({}, other, {\n      groupId\n    });\n    const subTreeLookup = createGroupLookup(children);\n    if (subTreeLookup[groupId] !== undefined || groupLookup[groupId] !== undefined) {\n      throw new Error(`MUI X: The groupId ${groupId} is used multiple times in the columnGroupingModel.`);\n    }\n    Object.assign(groupLookup, subTreeLookup);\n    groupLookup[groupId] = groupParam;\n  }\n  return groupLookup;\n};\n\n// This is the recurrence function that help writing `unwrapGroupingColumnModel()`\nconst recurrentUnwrapGroupingColumnModel = (columnGroupNode, parents, unwrappedGroupingModelToComplete) => {\n  if (isLeaf(columnGroupNode)) {\n    if (unwrappedGroupingModelToComplete[columnGroupNode.field] !== undefined) {\n      throw new Error([`MUI X: columnGroupingModel contains duplicated field`, `column field ${columnGroupNode.field} occurs two times in the grouping model:`, `- ${unwrappedGroupingModelToComplete[columnGroupNode.field].join(' > ')}`, `- ${parents.join(' > ')}`].join('\\n'));\n    }\n    unwrappedGroupingModelToComplete[columnGroupNode.field] = parents;\n    return;\n  }\n  const {\n    groupId,\n    children\n  } = columnGroupNode;\n  children.forEach(child => {\n    recurrentUnwrapGroupingColumnModel(child, [...parents, groupId], unwrappedGroupingModelToComplete);\n  });\n};\n\n/**\n * This is a function that provide for each column the array of its parents.\n * Parents are ordered from the root to the leaf.\n * @param columnGroupingModel The model such as provided in DataGrid props\n * @returns An object `{[field]: groupIds}` where `groupIds` is the parents of the column `field`\n */\nexport const unwrapGroupingColumnModel = columnGroupingModel => {\n  if (!columnGroupingModel) {\n    return {};\n  }\n  const unwrappedSubTree = {};\n  columnGroupingModel.forEach(columnGroupNode => {\n    recurrentUnwrapGroupingColumnModel(columnGroupNode, [], unwrappedSubTree);\n  });\n  return unwrappedSubTree;\n};\nexport const getColumnGroupsHeaderStructure = (orderedColumns, unwrappedGroupingModel, pinnedFields) => {\n  const getParents = field => unwrappedGroupingModel[field] ?? [];\n  const groupingHeaderStructure = [];\n  const maxDepth = Math.max(0, ...orderedColumns.map(field => getParents(field).length));\n  const haveSameParents = (field1, field2, depth) => {\n    const a = getParents(field1);\n    const b = getParents(field2);\n    for (let i = 0; i <= depth; i += 1) {\n      if (a[i] !== b[i]) {\n        return false;\n      }\n    }\n    return true;\n  };\n  const haveDifferentContainers = (field1, field2) => {\n    const left = pinnedFields?.left;\n    const right = pinnedFields?.right;\n    const inLeft1 = !!left?.includes(field1);\n    const inLeft2 = !!left?.includes(field2);\n    const inRight1 = !!right?.includes(field1);\n    const inRight2 = !!right?.includes(field2);\n    return inLeft1 !== inLeft2 || inRight1 !== inRight2;\n  };\n  for (let depth = 0; depth < maxDepth; depth += 1) {\n    const depthStructure = [];\n    for (let i = 0; i < orderedColumns.length; i += 1) {\n      const field = orderedColumns[i];\n      const groupId = getParents(field)[depth] ?? null;\n      if (depthStructure.length === 0) {\n        depthStructure.push({\n          columnFields: [field],\n          groupId\n        });\n        continue;\n      }\n      const lastGroup = depthStructure[depthStructure.length - 1];\n      const prevField = lastGroup.columnFields[lastGroup.columnFields.length - 1];\n      if (lastGroup.groupId !== groupId || !haveSameParents(prevField, field, depth) || haveDifferentContainers(prevField, field)) {\n        depthStructure.push({\n          columnFields: [field],\n          groupId\n        });\n      } else {\n        lastGroup.columnFields.push(field);\n      }\n    }\n    groupingHeaderStructure.push(depthStructure);\n  }\n  return groupingHeaderStructure;\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}